import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.resolve(__dirname, '..');

// Read Tokens Studio JSON files
const semanticLight = JSON.parse(
  fs.readFileSync(path.join(rootDir, 'tokens/source/sementic-light.json'), 'utf8')
);
const semanticDark = JSON.parse(
  fs.readFileSync(path.join(rootDir, 'tokens/source/sementic-dark.json'), 'utf8')
);
const primitives = JSON.parse(
  fs.readFileSync(path.join(rootDir, 'tokens/source/primitives.json'), 'utf8')
);

// Build primitive lookup map
function buildPrimitiveMap(obj, prefix = []) {
  const map = {};
  
  for (const [key, value] of Object.entries(obj)) {
    if (value && typeof value === 'object' && '$value' in value) {
      // Found a primitive token
      const fullKey = prefix.length > 0 ? `${prefix.join('.')}.${key}` : key;
      map[fullKey] = value.$value;
      
      // Also add shorthand (e.g., White, Black)
      if (prefix.length === 0) {
        map[key] = value.$value;
      }
    } else if (value && typeof value === 'object' && !Array.isArray(value)) {
      // Nested object, recurse
      Object.assign(map, buildPrimitiveMap(value, [...prefix, key]));
    }
  }
  
  return map;
}

const primitiveMap = buildPrimitiveMap(primitives);

// Resolve primitive references like {White}, {Zinc.950}
function resolvePrimitive(value) {
  if (typeof value === 'string' && value.startsWith('{') && value.endsWith('}')) {
    const ref = value.slice(1, -1); // Remove { }
    return primitiveMap[ref] || value; // Return resolved value or keep original if not found
  }
  return value;
}

// Flatten nested object to path-value pairs
function flattenTokens(obj, prefix = [], result = {}) {
  for (const [key, value] of Object.entries(obj)) {
    const newPath = [...prefix, key];
    
    if (value && typeof value === 'object' && '$value' in value) {
      // Token found
      const tokenPath = newPath.map((p) => p.charAt(0).toLowerCase() + p.slice(1)).join('-');
      const resolvedValue = resolvePrimitive(value.$value);
      result[tokenPath] = resolvedValue;
    } else if (value && typeof value === 'object' && !Array.isArray(value)) {
      // Nested object, recurse
      flattenTokens(value, newPath, result);
    }
  }
  return result;
}

// Flatten semantic tokens
const lightTokens = flattenTokens(semanticLight);
const darkTokens = flattenTokens(semanticDark);

// Convert camelCase to kebab-case
function toKebabCase(str) {
  return str.replace(/([A-Z])/g, '-$1').toLowerCase().replace(/^-/, '');
}

// Generate CSS variables
function generateCSS(tokens, selector) {
  let css = `${selector} {\n`;
  
  for (const [key, value] of Object.entries(tokens)) {
    const cssVarName = toKebabCase(key);
    css += `  --${cssVarName}: ${value};\n`;
  }
  
  css += '}\n';
  return css;
}

// Generate Tailwind config with kebab-case keys
function generateTailwindConfig(tokens) {
  const colors = {};
  
  for (const [key, value] of Object.entries(tokens)) {
    const cssVarName = toKebabCase(key);
    const tailwindKey = toKebabCase(key);
    colors[tailwindKey] = `var(--${cssVarName})`;
  }
  
  return `// Auto-generated from Tokens Studio JSON
// Do not edit this file manually. Run 'npm run tokens:build' to regenerate.

module.exports = {
  colors: ${JSON.stringify(colors, null, 2).replace(/"/g, "'")},
};`;
}

// Write CSS files
const lightCSS = generateCSS(lightTokens, ':root');
const darkCSS = generateCSS(darkTokens, '[data-theme="dark"]');

fs.writeFileSync(path.join(rootDir, 'app/tokens.css'), lightCSS);
fs.writeFileSync(path.join(rootDir, 'app/tokens-dark.css'), darkCSS);

// Write Tailwind config
const tailwindConfig = generateTailwindConfig(lightTokens);
fs.writeFileSync(path.join(rootDir, 'tokens/tailwind.tokens.js'), tailwindConfig);

console.log('âœ… Tokens built successfully!');
console.log('  - app/tokens.css');
console.log('  - app/tokens-dark.css');
console.log('  - tokens/tailwind.tokens.js');
